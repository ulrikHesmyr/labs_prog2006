use std::io;

enum Datatype {
    String,
    List,
    Codeblock,
}

enum Token {
    Operator(Operator),
    Float(f64),
    Int(i64),
    String(String),
}

enum Operator {
    Add,
    Subtract,
    Divide,
    Multiply,
}

impl Operator {
    fn add(&self, n : Token::Int, m : Token::Int) {
        n + m
    }
}


struct Program {
    statements : HashMap<String, Vec<Token>>
}

impl Program {
    fn interpret(&mut self, variable : Option<String>, argument : Vec<Token>){
        if let var = Some(variable) {
            self.statements.put(var, argument); //Use put because if we were to redeclare a variable, it will be overwritten 
        } 

        self.validate(argument);
    }

    //
    fn validate()
}

trait Arithmetic {
    fn add()
}

trait Stack {
    fn push_back(&mut self, element : Any)
    fn pop_back(&mut self) -> Any
}

impl Stack for Vec {
    fn push_back(&mut self, element : Any) {
        self.push(element);
    }

    fn pop_back(&mut self) -> Any {
        self.truncate(self.len()-1);
    }

}

fn main(){
    //Read a line of input from stdin
    let line = read_line()
}

fn read_line() -> Vec<Token> {
    let mut input = String::new();
    match io::stdin().read_line(&mut input) {
        Ok(n)
    }
}


fn tokenize(line : String) -> (Option<Variable>, Vec<Token>) {
    let words : Vec<&str> = line.split(" ").rev().collect();
    for word in words 
}

fn token(t : String) -> Token {
    
    if t.parse::<i64>().is_ok() {
        return Token::Int(t.parse::<i64>())
    } else if t.parse::<f64>.is_ok() {
        return Token::Float(t.parse::<f64>())
    } else if let o = Some(operator(t)) {
        return Token::Operator(o)
    } else {
        return Token::String(t)
    }
}

fn operator(t : String) -> Option<Operator> {
    match t {
        "+" => Some(Operator::Add),
        "-" => Some(Operator::Subtract),
        "/" => Some(Operator::Divide),
        "*" => Some(Operator::Multiply),
        _ => None
    }
}